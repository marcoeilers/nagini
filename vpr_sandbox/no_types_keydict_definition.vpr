import "./pytype.sil"

field keydict_val: Option[Ref]

adt Option[T] {
    Some(value:T)
    None()
}


function seq_int_str___box__(prim: Seq[Int]): Ref
    ensures typeof(result) == seq_int_str()
    ensures seq_int_str___unbox__(result) == prim

function seq_int_str___unbox__(box: Ref): Seq[Int]
    requires issubtype(typeof(box), seq_int_str())
    ensures  seq_int_str___box__(result) == box

function __prim__int___box__(prim: Int): Ref
  decreases _
  ensures typeof(result) == int()
  ensures int___unbox__(result) == prim

function int___unbox__(box: Ref): Int
  decreases _
  requires issubtype(typeof(box), int())
  ensures !issubtype(typeof(box), bool()) ==>
    __prim__int___box__(result) == box
  ensures issubtype(typeof(box), bool()) ==>
    __prim__bool___box__(result != 0) == box

function int___gt__(self: Int, other: Int): Bool
  decreases _
{
  self > other
}

function int___lt__(self: Int, other: Int): Bool
  decreases _
{
  self < other
}

function int___eq__(self: Ref, other: Ref): Bool
  decreases _
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int())
{
  int___unbox__(self) == int___unbox__(other)
}

function __prim__bool___box__(prim: Bool): Ref
  decreases _
  ensures typeof(result) == bool()
  ensures bool___unbox__(result) == prim
  ensures int___unbox__(result) == (prim ? 1 : 0)

function bool___unbox__(box: Ref): Bool
  decreases _
  requires issubtype(typeof(box), bool())
  ensures __prim__bool___box__(result) == box


method keydict___init__(self: Ref)
    ensures forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val) && !keydict___contains__(self, key)

function keydict___item__(self: Ref, key: Ref): Ref
    ensures keydict___item__inv(self, result) == key

function keydict___item__inv(self: Ref, val_ref: Ref): Ref

function keydict___contains__(self: Ref, key: Ref) : Bool
    requires acc(keydict___item__(self, key).keydict_val, wildcard)
{
  keydict___item__(self, key).keydict_val.isSome
}

function keydict___getitem__(self: Ref, key: Ref) : Ref
    requires acc(keydict___item__(self, key).keydict_val, wildcard)
    requires keydict___contains__(self, key)
{
  keydict___item__(self, key).keydict_val.value
}

method keydict___setitem__(self: Ref, key: Ref, item: Ref)
    requires acc(keydict___item__(self, key).keydict_val)
    ensures acc(keydict___item__(self, key).keydict_val)
    ensures keydict___item__(self, key).keydict_val.value == item
    ensures keydict___contains__(self, key)
    ensures keydict___getitem__(self, key) == item
{
    keydict___item__(self, key).keydict_val := Some(item)
    // assert 10 == 15   // sanity check
}

// Of all possible keys, which have been set in the keydict
function keydict_keys(self:Ref ): Set[Ref]
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall key: Ref :: {keydict___contains__(self, key)} {key in result} keydict___contains__(self, key) == (key in result)

// Of the keys in the Set[Ref], which have been set in the keydict
function keydict_keys_specific(self: Ref, keys: Set[Ref]): Set[Ref]
    requires forall key: Ref :: {key in keys} key in keys ==> acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall key: Ref :: {key in keys} key in keys ==> keydict___contains__(self, key) == (key in result)

function keydict_values(self: Ref): Set[Ref]
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall value: Ref :: {value in result}
    (exists key:Ref :: {keydict___contains__(self, key)} (keydict___contains__(self, key) && (keydict___getitem__(self, key) == value))) == value in result


function keydict___len__(self: Ref): Int
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures result == |keydict_keys(self)|
