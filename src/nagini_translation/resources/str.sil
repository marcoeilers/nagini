/*
 * Copyright (c) 2019 ETH Zurich
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

function str___len__(self: Ref): Int
    decreases _
	ensures result >= 0

function str___val__(self: Ref): Seq[Int]
    decreases _

function str___create__(len: Int, value: Seq[Int]) : Ref
    decreases _
	ensures str___len__(result) == len
	ensures str___val__(result) == value
	ensures typeof(result) == str()

function str___bool__(self: Ref) : Bool
    decreases _
    requires self != null ==> issubtype(typeof(self), str())
	ensures self != null ==> result == str___len__(self) != 0
	ensures self == null ==> !result

function str___eq__(self: Ref, other: Ref): Bool
    decreases _
    requires issubtype(typeof(self), str())
    ensures (str___val__(self) == str___val__(other)) == result
    ensures result ==> (str___len__(self) == str___len__(other))
    ensures result == object___eq__(self, other)

function str___add__(self: Ref, other: Ref): Ref
    decreases _
    requires issubtype(typeof(self), str())
    ensures str___len__(result) == str___len__(self) + str___len__(other)
    ensures typeof(result) == str()
    ensures result == str___create__(str___len__(self) + str___len__(other), str___val__(self) ++ str___val__(other))

function str___getitem_slice__(self: Ref, index: Ref): Ref
    decreases _
    requires issubtype(typeof(self), str())
    requires issubtype(typeof(index), slice())
    requires (slice___start__(index, str___len__(self)) >= 0 && slice___start__(index, str___len__(self)) <= str___len__(self))
    requires (slice___stop__(index, str___len__(self)) >= 0 && slice___stop__(index, str___len__(self)) <= str___len__(self))
    ensures issubtype(typeof(result), str())
    ensures str___len__(result) == (slice___stop__(index, str___len__(self)) - slice___start__(index, str___len__(self)))
    ensures str___val__(result) == str___val__(self)[slice___start__(index, str___len__(self))..slice___stop__(index, str___len__(self))]

function str_join(self: Ref, other: Ref): Ref
    decreases _
    requires issubtype(typeof(self), str())
    ensures issubtype(typeof(result), str())

function str___mod__(self: Ref, other: Ref): Ref
    decreases _
    requires issubtype(typeof(self), str())
    ensures issubtype(typeof(result), str())

method str_split(self: Ref) returns (res: Ref)
    decreases _
    requires issubtype(typeof(self), str())
    ensures issubtype(typeof(res), list(str()))
    ensures acc(res.list_acc)

adt Option[T] {
    Some(value:T)
    None()
}

field keydict_val: Option[Ref]

method keydict___init__(self: Ref)
    ensures forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val) && !keydict___contains__(self, key)

function keydict___item__(self: Ref, key: Ref): Ref
    ensures keydict___item__inv(self, result) == key

function keydict___item__inv(self: Ref, val_ref: Ref): Ref

function keydict___contains__(self: Ref, key: Ref) : Bool
    requires acc(keydict___item__(self, key).keydict_val, wildcard)
{
  keydict___item__(self, key).keydict_val.isSome
}

function keydict___getitem__(self: Ref, key: Ref) : Ref
    requires acc(keydict___item__(self, key).keydict_val, wildcard)
    requires keydict___contains__(self, key)
{
  keydict___item__(self, key).keydict_val.value
}

method keydict___setitem__(self: Ref, key: Ref, item: Ref)
    requires acc(keydict___item__(self, key).keydict_val)
    ensures acc(keydict___item__(self, key).keydict_val)
    ensures keydict___item__(self, key).keydict_val.value == item
    ensures keydict___contains__(self, key)
    ensures keydict___getitem__(self, key) == item
{
    keydict___item__(self, key).keydict_val := Some(item)
    // assert 10 == 15   // sanity check
}

// Of all possible keys, which have been set in the keydict
function keydict_keys(self:Ref ): Set[Ref]
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall key: Ref :: {keydict___contains__(self, key)} {key in result} keydict___contains__(self, key) == (key in result)

// Of the keys in the Set[Ref], which have been set in the keydict
function keydict_keys_specific(self: Ref, keys: Set[Ref]): Set[Ref]
    requires forall key: Ref :: {key in keys} key in keys ==> acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall key: Ref :: {key in keys} key in keys ==> keydict___contains__(self, key) == (key in result)

function keydict_values(self: Ref): Set[Ref]
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures forall value: Ref :: {value in result}
    (exists key:Ref :: {keydict___contains__(self, key)} (keydict___contains__(self, key) && (keydict___getitem__(self, key) == value))) == value in result


function keydict___len__(self: Ref): Int
    requires forall key: Ref :: {keydict___item__(self, key)} acc(keydict___item__(self, key).keydict_val, wildcard)
    ensures result == |keydict_keys(self)|
