/*
 * Copyright (c) 2025 ETH Zurich
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

field bytearray_acc : Seq[Int]

// Bytearray only accepts values in the range [0, 255]
function bytearray___bounds_helper__(value: Int): Bool
    decreases _
{
    0 <= value < 256
}

method bytearray___init__() returns (res: Ref)
    ensures acc(res.bytearray_acc)
    ensures res.bytearray_acc == Seq[Int]()
    ensures typeof(res) == bytearray()
    ensures Low(res)

method bytearray___initFromInt__(length: Ref) returns (res: Ref)
    requires issubtype(typeof(length), int())
    ensures typeof(res) == bytearray()
    ensures acc(res.bytearray_acc)
    ensures |res.bytearray_acc| == int___unbox__(length)
    ensures (forall i: Int :: { res.bytearray_acc[i] } 0 <= i < int___unbox__(length) ==> res.bytearray_acc[i] == 0)
    ensures Low(length) ==> Low(res)

method bytearray___initFromBytearray__(other: Ref) returns (res: Ref)
    requires issubtype(typeof(other), bytearray())
    requires acc(other.bytearray_acc, 1/1000)
    ensures acc(other.bytearray_acc, 1/1000)
    ensures acc(res.bytearray_acc)
    ensures res.bytearray_acc == other.bytearray_acc
    ensures typeof(res) == bytearray()
    ensures Low(other) ==> Low(res)

method bytearray___initFromList__(values: Ref) returns (res: Ref)
    requires issubtype(typeof(values), list(int()))
    requires acc(values.list_acc, 1/1000)
    requires forall i: Int :: {values.list_acc[i]} ((0 <= i < list___len__(values)) ==> bytearray___bounds_helper__(int___unbox__(list___getitem__(values, __prim__int___box__(i)))))
    ensures acc(values.list_acc, 1/1000)
    ensures acc(res.bytearray_acc)
    ensures typeof(res) == bytearray()
    ensures res.bytearray_acc == __seq_ref_to_seq_int(values.list_acc)
    ensures Low(values) ==> Low(res)
    
function bytearray___len__(self: Ref) : Int
    decreases _
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc, wildcard)
    ensures result >= 0
{
    |self.bytearray_acc|
}

function bytearray___contains__(self: Ref, key: Ref): Bool
    decreases _
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc, wildcard)
    requires issubtype(typeof(key), int())
    ensures result == (int___unbox__(key) in self.bytearray_acc)

function bytearray___bool__(self: Ref) : Bool
    decreases _
    requires self != null ==> issubtype(typeof(self), bytearray())
    requires self != null ==> acc(self.bytearray_acc, wildcard)
    ensures self == null ==> !result
    ensures self != null ==> result == (|self.bytearray_acc| != 0)

// function bytearray___hex__(self: Ref): Str
//     decreases _
//     requires issubtype(typeof(self), bytearray())
//     requires acc(self.bytearray_acc, wildcard)
//     ensures result == 

function bytearray___getitem__(self: Ref, key: Ref): Int
    decreases _
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc, wildcard)
    requires issubtype(typeof(key), int())
    requires @error("Bytearray index may be out of bounds.")(let ln == (bytearray___len__(self)) in (int___unbox__(key) < 0 ==> int___unbox__(key) >= -ln))
    requires @error("Bytearray index may be out of bounds.")(let ln == (bytearray___len__(self)) in (int___unbox__(key) >= 0 ==> int___unbox__(key) < ln))
    ensures result == (int___unbox__(key) >= 0 ? self.bytearray_acc[int___unbox__(key)] : self.bytearray_acc[bytearray___len__(self) + int___unbox__(key)])
    ensures bytearray___bounds_helper__(result)

method bytearray___getitem_slice__(self: Ref, key: Ref) returns (_res: Ref)
    requires issubtype(typeof(self), bytearray())
    requires issubtype(typeof(key), slice())
    requires acc(self.bytearray_acc, 1/1000)
    ensures acc(self.bytearray_acc, 1/1000)
    ensures acc(_res.bytearray_acc)
    ensures typeof(_res) == bytearray()
    ensures _res.bytearray_acc == self.bytearray_acc[slice___start__(key, bytearray___len__(self))..slice___stop__(key, bytearray___len__(self))]

method bytearray___setitem__(self: Ref, key: Ref, value: Ref) returns ()
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc)
    requires issubtype(typeof(key), int())
    requires @error("Bytearray index may be negative.")(int___unbox__(key) >= 0)
    requires @error("Bytearray index may be out of bounds.")(int___unbox__(key) < bytearray___len__(self))
    requires issubtype(typeof(value), int())
    requires @error("Provided value may be out of bounds.")bytearray___bounds_helper__(int___unbox__(value))
    ensures acc(self.bytearray_acc)
    ensures self.bytearray_acc == old(self.bytearray_acc)[int___unbox__(key) := int___unbox__(value)]
    ensures (Low(key) && Low(value)) ==> (forall i: Ref :: {bytearray___getitem__(self, i)} ((issubtype(typeof(i), int()) && int___unbox__(i) >= 0 && int___unbox__(i) < bytearray___len__(self) && Low(old(bytearray___getitem__(self, i)))) ==> Low(bytearray___getitem__(self, i))))

method bytearray_append(self: Ref, item: Ref) returns ()
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc)
    requires issubtype(typeof(item), int())
    requires @error("Provided item may be out of bounds.")bytearray___bounds_helper__(int___unbox__(item))
    ensures acc(self.bytearray_acc)
    ensures self.bytearray_acc == old(self.bytearray_acc) ++ Seq(int___unbox__(item))

// Actual type of other is Iterable[SupportsIndex]
method bytearray_extend(self: Ref, other: Ref) returns ()
    requires issubtype(typeof(self), bytearray())
    requires issubtype(typeof(other), bytearray())
    requires acc(self.bytearray_acc)
    requires acc(other.bytearray_acc, 1/100)
    ensures acc(self.bytearray_acc)
    ensures acc(other.bytearray_acc, 1/100)
    ensures self.bytearray_acc == old(self.bytearray_acc) ++ other.bytearray_acc

method bytearray_reverse(self: Ref) returns ()
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc)
    ensures acc(self.bytearray_acc)
    ensures old(bytearray___len__(self)) == bytearray___len__(self)
    ensures forall i: Int :: {self.bytearray_acc[i]} ((i >= 0 && i < bytearray___len__(self)) ==> (self.bytearray_acc[i] == old(self.bytearray_acc[bytearray___len__(self) - 1 - i])))

method bytearray___iter__(self: Ref) returns (_res: Ref)
    requires issubtype(typeof(self), bytearray())
    requires acc(self.bytearray_acc, 1/ 20)
    ensures _res != self
    ensures acc(_res.list_acc, 1 / 20)
    ensures acc(self.bytearray_acc, 1 / 20)
    ensures _res.list_acc == bytearray___sil_seq__(self)
    ensures acc(_res.__container, write) && (_res.__container == self)
    ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
    ensures acc(_res.__previous, write) && _res.__previous == Seq[Ref]()
    ensures issubtype(typeof(_res), Iterator(int()))

function bytearray___sil_seq__(self: Ref): Seq[Ref]
  decreases _
  requires issubtype(typeof(self), bytearray()) 
  requires acc(self.bytearray_acc, wildcard)
  ensures |result| == bytearray___len__(self)
  ensures (forall i: Int :: { result[i] } 0 <= i < bytearray___len__(self) ==> result[i] == __prim__int___box__(self.bytearray_acc[i]))
  ensures (forall i: Ref :: { (i in result) } (i in result) == (typeof(i) == int() && (int___unbox__(i) in self.bytearray_acc)))
  ensures (forall i: Ref :: { (i in result) } (i in result) ==> bytearray___bounds_helper__(int___unbox__(i)))