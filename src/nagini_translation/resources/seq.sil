/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

function Sequence___create__(prim: Seq[Ref], cont_type: PyType): Ref
    ensures typeof(result) == Sequence(cont_type)
    ensures Sequence___unbox__(result) == prim

function Sequence___unbox__(box: Ref): Seq[Ref]
    requires issubtype(typeof(box), Sequence(Sequence_arg(typeof(box), 0)))

function Sequence___contains__(self: Ref, item: Ref): Bool
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == (item in Sequence___unbox__(self))
    ensures result ==> issubtype(typeof(item), Sequence_arg(typeof(self), 0))

function Sequence___getitem__(self: Ref, index: Ref): Ref
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    requires issubtype(typeof(index), int())
    requires (int___unbox__(index) >= 0 && int___unbox__(index) < Sequence___len__(self))
    ensures result == Sequence___unbox__(self)[int___unbox__(index)]
    ensures issubtype(typeof(result), Sequence_arg(typeof(self), 0))

function Sequence___sil_seq__(self: Ref): Seq[Ref]
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == Sequence___unbox__(self)

function Sequence___len__(self: Ref): Int
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == |Sequence___unbox__(self)|

function Sequence_take(self: Ref, no: Int): Ref
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == Sequence___create__(Sequence___unbox__(self)[..no], Sequence_arg(typeof(self), 0))

function Sequence_drop(self: Ref, no: Int): Ref
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == Sequence___create__(Sequence___unbox__(self)[no..], Sequence_arg(typeof(self), 0))

function Sequence_update(self: Ref, index: Int, val: Ref): Ref
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    ensures result == Sequence___create__(Sequence___unbox__(self)[index := val], Sequence_arg(typeof(self), 0))

function Sequence___add__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    requires issubtype(typeof(other), Sequence(Sequence_arg(typeof(other), 0)))
    requires Sequence_arg(typeof(self), 0) == Sequence_arg(typeof(other), 0)
    ensures result == Sequence___create__(Sequence___unbox__(self) ++ Sequence___unbox__(other), Sequence_arg(typeof(self), 0))

function Sequence___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), Sequence(Sequence_arg(typeof(self), 0)))
    requires issubtype(typeof(other), Sequence(Sequence_arg(typeof(other), 0)))
    requires Sequence_arg(typeof(self), 0) == Sequence_arg(typeof(other), 0)
    ensures result == (Sequence___unbox__(self) == Sequence___unbox__(other))

function PSet___create__(prim: Set[Ref], cont_type: PyType): Ref
    ensures typeof(result) == PSet(cont_type)
    ensures PSet___unbox__(result) == prim

function PSet___unbox__(box: Ref): Set[Ref]
    requires issubtype(typeof(box), PSet(PSet_arg(typeof(box), 0)))

function PSet___contains__(self: Ref, item: Ref): Bool
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    ensures result == (item in PSet___unbox__(self))
    ensures result ==> issubtype(typeof(item), PSet_arg(typeof(self), 0))

function PSet___sil_seq__(self: Ref): Seq[Ref]
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    ensures forall r: Ref :: {r in result} r in result == r in PSet___unbox__(self)
    ensures |result| == |PSet___unbox__(self)|

function PSet___len__(self: Ref): Int
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    ensures result == |PSet___unbox__(self)|

function PSet___add__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    requires issubtype(typeof(other), PSet(PSet_arg(typeof(other), 0)))
    requires PSet_arg(typeof(self), 0) == PSet_arg(typeof(other), 0)
    ensures result == PSet___create__(PSet___unbox__(self) union PSet___unbox__(other), PSet_arg(typeof(self), 0))

function PSet___sub__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    requires issubtype(typeof(other), PSet(PSet_arg(typeof(other), 0)))
    requires PSet_arg(typeof(self), 0) == PSet_arg(typeof(other), 0)
    ensures result == PSet___create__(PSet___unbox__(self) setminus PSet___unbox__(other), PSet_arg(typeof(self), 0))

function PSet___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), PSet(PSet_arg(typeof(self), 0)))
    requires issubtype(typeof(other), PSet(PSet_arg(typeof(other), 0)))
    requires PSet_arg(typeof(self), 0) == PSet_arg(typeof(other), 0)
    ensures result == (PSet___unbox__(self) == PSet___unbox__(other))
