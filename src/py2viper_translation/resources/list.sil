field list_acc : Seq[Ref]

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    function get_type_arg1(obj: Ref, index: Int): PyType
    function get_type_arg2(obj: Ref, index: Int, index2: Int): PyType
    function get_type_arg3(obj: Ref, index: Int, index2: Int, index3: Int): PyType
    function get_type_arg4(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int): PyType
    function get_type_arg5(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int): PyType
    function get_type_arg6(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int, index6: Int): PyType
    function get_type_nargs0(r: Ref): Int
    function get_type_nargs1(r: Ref, index: Int): Int
    function get_type_nargs2(r: Ref, index: Int, index2: Int): Int
    function get_type_nargs3(r: Ref, index: Int, index2: Int, index3: Int): Int
    function get_type_nargs4(r: Ref, index: Int, index2: Int, index3: Int, index4: Int): Int
    function get_type_nargs5(r: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int): Int
    unique function list(): PyType
}

method list___init__() returns (res: Ref)
    ensures acc(res.list_acc)
    ensures res.list_acc == Seq[Ref]()
    ensures typeof(res) == list()
{
    assume false
}

function list___contains__(self: Ref, item: Ref): Bool
    requires acc(self.list_acc, 1/100)
    ensures result == (item in self.list_acc)

function list___bool__(self: Ref) : Bool
    requires acc(self.list_acc, 1/100)
    ensures result == (|self.list_acc| != 0)

function list___len__(self: Ref) : Int
    requires acc(self.list_acc, 1/100)
{
 |self.list_acc|
}

function list___getitem__(self: Ref, key: Int): Ref
    requires acc(self.list_acc, 1/100)
    requires key >= 0
    requires key < list___len__(self)
    ensures result == self.list_acc[key]
    ensures (get_type_nargs0(result) == get_type_nargs1(self, 0)) &&
    (forall i1: Int :: {get_type_nargs1(result, i1)} get_type_nargs1(result, i1) == get_type_nargs2(self, 0, i1)) &&
    (forall i1: Int, i2: Int :: {get_type_nargs2(result, i1, i2)} get_type_nargs2(result, i1, i2) == get_type_nargs3(self, 0, i1, i2))
    ensures args_equal(self, result, 0)
//    ensures forall index : Seq[Int] :: {get_type_nargs(result, index)} get_type_nargs(result, index) == get_type_nargs(self, Seq(0) ++ index)
//    ensures forall index : Seq[Int] :: {get_type_arg(result, index)} get_type_arg(result, index) == get_type_arg(self, Seq(0) ++ index)

method list___setitem__(self: Ref, key: Int, item: Ref) returns ()
    requires acc(self.list_acc)
    requires key >= 0
    requires key < list___len__(self)
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc)[key := item]
{
    assume false
}

method list_append(self: Ref, item: Ref) returns ()
    requires acc(self.list_acc)
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc) ++ Seq(item)
{
    assume false
}

function nargs_equal(self: Ref, res: Ref, index: Int): Bool
{
    (get_type_nargs0(res) == get_type_nargs1(self, index)) &&
    (forall i1: Int :: {get_type_nargs1(res, i1)} get_type_nargs1(res, i1) == get_type_nargs2(self, index, i1)) &&
    (forall i1: Int, i2: Int :: {get_type_nargs2(res, i1, i2)} get_type_nargs2(res, i1, i2) == get_type_nargs3(self, index, i1, i2))
}

function args_equal(self: Ref, res: Ref, index: Int): Bool
{
    (forall i1: Int :: get_type_arg1(res, i1) == get_type_arg2(self, index, i1)) &&
    (forall i1: Int, i2: Int :: get_type_arg2(res, i1, i2) == get_type_arg3(self, index, i1, i2))
}