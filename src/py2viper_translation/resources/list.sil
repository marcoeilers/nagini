field list_acc : Seq[Ref]

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    function get_type_arg1(obj: Ref, index: Int): PyType
    function get_type_arg2(obj: Ref, index: Int, index2: Int): PyType
    function get_type_arg3(obj: Ref, index: Int, index2: Int, index3: Int): PyType
    function get_type_arg4(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int): PyType
    function get_type_arg5(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int): PyType
    function get_type_arg6(obj: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int, index6: Int): PyType
    function get_type_nargs0(r: Ref): Int
    function get_type_nargs1(r: Ref, index: Int): Int
    function get_type_nargs2(r: Ref, index: Int, index2: Int): Int
    function get_type_nargs3(r: Ref, index: Int, index2: Int, index3: Int): Int
    function get_type_nargs4(r: Ref, index: Int, index2: Int, index3: Int, index4: Int): Int
    function get_type_nargs5(r: Ref, index: Int, index2: Int, index3: Int, index4: Int, index5: Int): Int
    unique function list(): PyType
}

method list___init__() returns (res: Ref)
    ensures acc(res.list_acc)
    ensures res.list_acc == Seq[Ref]()
    ensures typeof(res) == list()
{
    assume false
}

function list___contains__(self: Ref, item: Ref): Bool
    requires acc(self.list_acc, 1/100)
    ensures result == (item in self.list_acc)

function list___bool__(self: Ref) : Bool
    requires acc(self.list_acc, 1/100)
    ensures result == (|self.list_acc| != 0)

function list___len__(self: Ref) : Int
    requires acc(self.list_acc, 1/100)
{
 |self.list_acc|
}

function list___getitem__(self: Ref, key: Int): Ref
    requires acc(self.list_acc, 1/100)
    requires key >= 0
    requires key < list___len__(self)
    ensures result == self.list_acc[key]
    ensures (get_type_nargs0(result) == get_type_nargs1(self, 0)) &&
    (forall i1: Int :: {get_type_nargs1(result, i1)} get_type_nargs1(result, i1) == get_type_nargs2(self, 0, i1)) &&
    (forall i1: Int, i2: Int :: {get_type_nargs2(result, i1, i2)} get_type_nargs2(result, i1, i2) == get_type_nargs3(self, 0, i1, i2))
    ensures args_equal(self, result, 0)
//    ensures forall index : Seq[Int] :: {get_type_nargs(result, index)} get_type_nargs(result, index) == get_type_nargs(self, Seq(0) ++ index)
//    ensures forall index : Seq[Int] :: {get_type_arg(result, index)} get_type_arg(result, index) == get_type_arg(self, Seq(0) ++ index)

method list___setitem__(self: Ref, key: Int, item: Ref) returns ()
    requires acc(self.list_acc)
    requires key >= 0
    requires key < list___len__(self)
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc)[key := item]
{
    assume false
}

method list_append(self: Ref, item: Ref) returns ()
    requires acc(self.list_acc)
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc) ++ Seq(item)
{
    assume false
}

function nargs_equal(self: Ref, res: Ref, index: Int): Bool
{
    (get_type_nargs0(res) == get_type_nargs1(self, index)) &&
    (forall i1: Int :: {get_type_nargs1(res, i1)} get_type_nargs1(res, i1) == get_type_nargs2(self, index, i1)) &&
    (forall i1: Int, i2: Int :: {get_type_nargs2(res, i1, i2)} get_type_nargs2(res, i1, i2) == get_type_nargs3(self, index, i1, i2))
}

function args_equal(self: Ref, res: Ref, index: Int): Bool
{
    (forall i1: Int :: get_type_arg1(res, i1) == get_type_arg2(self, index, i1)) &&
    (forall i1: Int, i2: Int :: get_type_arg2(res, i1, i2) == get_type_arg3(self, index, i1, i2))
}

field __container : Ref
field __iter_index : Int
field __previous: Ref

method list___iter__(self: Ref) returns (_res: Ref)
  requires acc(self.list_acc, 1 / 10)
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures acc(self.list_acc, 1 / 20)
  ensures _res.list_acc == self.list_acc
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous) && _res.__previous != _res && _res.__previous != self &&  acc(_res.__previous.list_acc) && _res.__previous.list_acc == Seq[Ref]()
{
  inhale false
}

method Iterator___next__(self: Ref) returns (_res: Ref, _err: Ref)
  requires acc(self.list_acc, 1 / 40)
  requires acc(self.__iter_index, write)
  requires acc(self.__previous, 1/40) && acc(self.__previous.list_acc)
  ensures acc(self.list_acc, 1 / 40) && self.list_acc == old(self.list_acc)
  ensures acc(self.__iter_index, write) && (self.__iter_index == old(self.__iter_index) + 1)
  ensures old(|self.list_acc| > self.__iter_index) ==> ((_res == old(self.list_acc[self.__iter_index])) && _res in self.list_acc && (_err == null))
  ensures acc(self.__previous, 1/40) && self.__previous == old(self.__previous) && acc(self.__previous.list_acc) &&
  		(old(|self.list_acc| > self.__iter_index) ==> (self.__previous.list_acc == old(self.list_acc[..self.__iter_index])))
  ensures old(|self.list_acc| <= self.__iter_index) ==> (_err != null && self.__previous.list_acc == self.list_acc)
{
  inhale false
}

method Iterator___del__(self: Ref)
  requires acc(self.list_acc, 1 / 20)
  requires acc(self.__container, 1 / 20)
  ensures acc(self.__container, 1 / 20)
  ensures acc(self.__container.list_acc, 1 / 20)
{
  inhale false
}

predicate for_invariant(iter: Ref, collection_seq: Seq[Ref], iter_err: Ref, item: Ref){
	(acc(iter.list_acc, 1/20)) &&
  	(iter.list_acc == collection_seq) &&
  	(acc(iter.__iter_index)  && acc(iter.__previous, 1/20)  && acc(iter.__previous.list_acc)) &&
  	(iter_err == null ==> (iter.__iter_index >= 0 && iter.__iter_index <= |iter.list_acc|)) &&
  	(iter_err == null ==> (item == iter.list_acc[iter.__iter_index - 1] && item in iter.list_acc)) &&
  	(iter_err == null ==> (iter.__previous.list_acc == iter.list_acc[..iter.__iter_index - 1])) &&
  	(iter_err != null ==> (iter.__previous.list_acc == iter.list_acc))
}

function list___sil_seq__(self: Ref): Seq[Ref]
    requires acc(self.list_acc, 1/80)
{
    self.list_acc
}