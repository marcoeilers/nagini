field list_acc : Seq[Ref]
field set_acc : Set[Ref]
field dict_acc : Set[Ref]

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    function list(t: PyType): PyType
    function list_arg(t: PyType, i: Int): PyType
    function set_arg(t: PyType, i: Int): PyType
    function dict_arg(t: PyType, i: Int): PyType
    function Iterator(t: PyType): PyType
    function Iterator_arg(t: PyType, i: Int): PyType
    function set(t: PyType): PyType
    function dict(t: PyType, v: PyType): PyType
    unique function int(): PyType
    unique function range(): PyType
}

method list___init__() returns (res: Ref)
    ensures acc(res.list_acc)
    ensures res.list_acc == Seq[Ref]()
    ensures typeof(res) == list(list_arg(typeof(res), 0))
{
    assume false
}

function list___contains__(self: Ref, item: Ref): Bool
    requires acc(self.list_acc, wildcard)
    ensures result == (item in self.list_acc)

function list___bool__(self: Ref) : Bool
    requires acc(self.list_acc, wildcard)
    ensures result == (|self.list_acc| != 0)

function list___len__(self: Ref) : Int
    requires acc(self.list_acc, wildcard)
{
 |self.list_acc|
}

// Dummy for the version from bool.sil
function int___unbox__(self: Ref): Int

/*
// TODO: It would make sense to have functions like this for assertions we need
// for lots of different functions/methods (list___getitem__, Iterator___next__,
// list___iter__, ...), but it seems that Silicon doesn't always expand the
// function and becomes incomplete if we do that.
function type_args_plus_1(self: Ref, other: Ref, ind: Int): Bool
{
    (get_type_nargs0(other) == get_type_nargs1(self, ind)) &&
    (forall i1: Int :: {get_type_nargs1(other, i1)} get_type_nargs1(other, i1) == get_type_nargs2(self, ind, i1)) &&
    (forall i1: Int, i2: Int :: {get_type_nargs2(other, i1, i2)} get_type_nargs2(other, i1, i2) == get_type_nargs3(self, ind, i1, i2)) &&
    (forall i1: Int :: {get_type_arg1(other, i1)} get_type_arg1(other, i1) == get_type_arg2(self, ind, i1)) &&
    (forall i1: Int, i2 : Int :: {get_type_arg2(other, i1, i2)} get_type_arg2(other, i1, i2) == get_type_arg3(self, ind, i1, i2))
}

function type_arg_eq(self: Ref, other: Ref, ind1: Int, ind2: Int): Bool
{
    get_type_nargs1(other, ind2) == get_type_nargs1(self, ind1) &&
    (forall i1: Int :: {get_type_arg2(other, ind2, i1)} get_type_arg2(other, ind2, i1) == get_type_arg2(self, ind1, i1))
}*/

function list___getitem__(self: Ref, key: Ref): Ref
    requires issubtype(typeof(key), int())
    requires acc(self.list_acc, wildcard)
    requires int___unbox__(key) >= 0
    requires int___unbox__(key) < list___len__(self)
    ensures result == self.list_acc[int___unbox__(key)]
    ensures issubtype(typeof(result), list_arg(typeof(self), 0))

method list___setitem__(self: Ref, key: Int, item: Ref) returns ()
    requires acc(self.list_acc)
    requires key >= 0
    requires key < list___len__(self)
    requires issubtype(typeof(item), list_arg(typeof(self), 0))
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc)[key := item]
{
    assume false
}

method list_append(self: Ref, item: Ref) returns ()
    requires acc(self.list_acc)
    requires issubtype(typeof(item), list_arg(typeof(self), 0))
    ensures acc(self.list_acc)
    ensures self.list_acc == old(self.list_acc) ++ Seq(item)
{
    assume false
}

field __container : Ref
field __iter_index : Int
field __previous: Ref

method list___iter__(self: Ref) returns (_res: Ref)
  requires acc(self.list_acc, 1 / 10)
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures acc(self.list_acc, 1 / 20)
  ensures _res.list_acc == self.list_acc
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous, write) && ((_res.__previous != _res) && ((_res.__previous != self) && (acc(_res.__previous.list_acc, write) && (_res.__previous.list_acc == Seq[Ref]()))))
  ensures issubtype(typeof(_res), Iterator(list_arg(typeof(self), 0)))
  ensures issubtype(typeof(_res.__previous), list(list_arg(typeof(self), 0)))
{
  inhale false
}

method Iterator___next__(self: Ref) returns (_res: Ref, _err: Ref)
  requires acc(self.list_acc, 1 / 40)
  requires acc(self.__iter_index, write)
  requires acc(self.__previous, 1 / 40) && acc(self.__previous.list_acc, write)
  ensures acc(self.list_acc, 1 / 40) && (self.list_acc == old(self.list_acc))
  ensures acc(self.__iter_index, write)
  ensures old(self.__iter_index == |self.list_acc|) <==> _err != null
  ensures acc(self.__previous, 1 / 40) && (self.__previous == old(self.__previous)) && acc(self.__previous.list_acc, write)
  ensures _err == null ==> (self.__iter_index == old(self.__iter_index) + 1)
  ensures _err == null ==> self.__previous.list_acc == self.list_acc[..self.__iter_index - 1]
  ensures |self.list_acc| > 0 ==> _res == self.list_acc[self.__iter_index - 1] && _res in self.list_acc
  ensures _err != null ==> self.__previous.list_acc == self.list_acc
  ensures _err != null ==> self.__iter_index == |self.list_acc|
  ensures |self.list_acc| > 0 ==> issubtype(typeof(_res), Iterator_arg(typeof(self), 0))
{
  inhale false
}

method Iterator___del__(self: Ref)
  requires acc(self.list_acc, 1 / 20)
  requires acc(self.__container, 1 / 20)
  ensures acc(self.__container, 1 / 20)
  ensures (issubtype(typeof(self.__container), list(list_arg(typeof(self.__container), 0)))) ==> acc(self.__container.list_acc, 1 / 20)
  ensures (issubtype(typeof(self.__container), dict(dict_arg(typeof(self.__container), 0), dict_arg(typeof(self.__container), 1)))) ==> acc(self.__container.dict_acc, 1 / 20)
  ensures (issubtype(typeof(self.__container), set(set_arg(typeof(self.__container), 0)))) ==> acc(self.__container.set_acc, 1 / 20)
{
  inhale false
}

function list___sil_seq__(self: Ref): Seq[Ref]
    requires acc(self.list_acc, wildcard)
{
    self.list_acc
}