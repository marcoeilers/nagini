field set_acc : Set[Ref]

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    function get_type_nargs0(r: Ref): Int
    function get_type_arg1(r: Ref, a1: Int): PyType
    function get_type_nargs1(r: Ref, a1: Int): Int
    unique function set(): PyType
    unique function dict(): PyType
}

method set___init__() returns (res: Ref)
    ensures acc(res.set_acc)
    ensures res.set_acc == Set[Ref]()
    ensures typeof(res) == set()
    ensures get_type_nargs0(res) == 1
{
    assume false
}

function set___len__(self: Ref): Int
    requires acc(self.set_acc, wildcard)
    ensures result == |self.set_acc|

function set___contains__(self: Ref, item: Ref) : Bool
    requires acc(self.set_acc, wildcard)
    ensures result == (item in self.set_acc)

function set___bool__(self: Ref) : Bool
    requires acc(self.set_acc, wildcard)
    ensures result == (|self.set_acc| != 0)

field __container : Ref
field __iter_index : Int
field __previous: Ref
field list_acc : Seq[Ref]

method set___iter__(self: Ref) returns (_res: Ref)
  requires acc(self.set_acc, 1 / 10)
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures acc(self.set_acc, 1 / 20)
  ensures _res.list_acc == set___sil_seq__(self)
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous, write) && ((_res.__previous != _res) && ((_res.__previous != self) && (acc(_res.__previous.list_acc, write) && (_res.__previous.list_acc == Seq[Ref]()))))
{
  inhale false
}

method set_add(self: Ref, item: Ref) returns ()
    requires acc(self.set_acc)
    requires issubtype(typeof(item), get_type_arg1(self, 0))
    ensures acc(self.set_acc)
    ensures self.set_acc == old(self.set_acc) union Set(item)
    ensures get_type_nargs1(self, 0) == get_type_nargs0(item)
{
    assume false
}

method set_clear(self: Ref) returns ()
    requires acc(self.set_acc)
    ensures acc(self.set_acc)
    ensures self.set_acc == Set[Ref]()
{
    assume false
}

function set___sil_seq__(self: Ref): Seq[Ref]
    requires acc(self.set_acc, wildcard)
    ensures |result| == |self.set_acc|
    ensures forall c: Ref :: {c in self.set_acc} {c in result} c in self.set_acc <==> c in result
    ensures forall i: Int :: !(result[i] in result[..i])
    ensures forall r: Ref:: {r in result} r in result ==> issubtype(typeof(r), get_type_arg1(self, 0))

field dict_acc : Set[Ref]

method dict___init__() returns (res: Ref)
    ensures acc(res.dict_acc)
    ensures res.dict_acc == Set[Ref]()
    ensures typeof(res) == dict()
    ensures get_type_nargs0(res) == 2
{
    assume false
}

function dict___contains__(self: Ref, item: Ref) : Bool
    requires acc(self.dict_acc, wildcard)
    ensures result == (item in self.dict_acc)

method dict___iter__(self: Ref) returns (_res: Ref)
  requires acc(self.dict_acc, 1 / 10)
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures acc(self.dict_acc, 1 / 20)
  ensures _res.list_acc == dict___sil_seq__(self)
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous, write) && ((_res.__previous != _res) && ((_res.__previous != self) && (acc(_res.__previous.list_acc, write) && (_res.__previous.list_acc == Seq[Ref]()))))
{
  inhale false
}

function dict___bool__(self: Ref) : Bool
    requires acc(self.dict_acc, wildcard)
    ensures result == (|self.dict_acc| != 0)

method dict_keys(self: Ref) returns (res: Ref)
    requires acc(self.dict_acc, 1/100)
    ensures acc(self.dict_acc, 1/100)
    ensures acc(res.set_acc)
    ensures res.set_acc == self.dict_acc
{
    assume false
}

function dict___getitem__(self: Ref, key: Ref) : Ref
    requires acc(self.dict_acc, wildcard)
    requires dict___contains__(self, key)
    ensures get_type_nargs0(result) == get_type_nargs1(self, 1)

function dict_get(self: Ref, key: Ref) : Ref
    requires acc(self.dict_acc, wildcard)
    ensures result == (dict___contains__(self, key) ? dict___getitem__(self,key) : null)

method dict___setitem__(self: Ref, key: Ref, item: Ref) returns ()
    requires acc(self.dict_acc)
    requires issubtype(typeof(item), get_type_arg1(self, 1))
    ensures acc(self.dict_acc)
    ensures self.dict_acc == old(self.dict_acc) union Set(key)
    ensures dict___getitem__(self, key) == item
    ensures get_type_nargs1(self, 0) == get_type_nargs0(key)
    ensures get_type_nargs1(self, 1) == get_type_nargs0(item)
    ensures forall k : Ref ::
        {dict___getitem__(self, k)}
        {old(dict___getitem__(self, k))}
        {old(dict___contains__(self, k))}
        {dict___contains__(self, k)}
        ((old(dict___contains__(self, k)) && k != key)
        ==>
        (dict___contains__(self, k) &&
        (dict___getitem__(self, k) == old(dict___getitem__(self, k)))))
{
    assume false
}

method dict_values(self: Ref) returns (_res: Ref)
    requires acc(self.dict_acc, 1/100)
    ensures acc(self.dict_acc, 1/100)
    ensures self.dict_acc == old(self.dict_acc)
    ensures typeof(_res) == set()
    ensures acc(_res.set_acc)
    ensures |_res.set_acc| == |self.dict_acc|
    ensures (forall k: Ref :: { dict___contains__(self, k) } {k in self.dict_acc} (dict___contains__(self, k)) ==> (dict___getitem__(self, k) in _res.set_acc))
    ensures get_type_nargs0(_res) == 1 && get_type_arg1(_res, 0) == get_type_arg1(self, 1)

function dict___len__(self: Ref): Int
    requires acc(self.dict_acc, wildcard)
    ensures result == |self.dict_acc|

function dict___sil_seq__(self: Ref): Seq[Ref]
    requires acc(self.dict_acc, wildcard)
    ensures |result| == |self.dict_acc|
    ensures forall c: Ref :: {c in self.dict_acc} {c in result} c in self.dict_acc <==> c in result