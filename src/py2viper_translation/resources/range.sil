function range___create__(start: Int, stop: Int, ctr: Int): Ref
  requires stop >= start
  ensures range___val__(result) == [start..stop)
  ensures range___start__(result) == start
  ensures range___stop__(result) == stop
  ensures typeof(result) == range()


function range___val__(self: Ref): Seq[Int]
function range___start__(self: Ref): Int
function range___stop__(self: Ref): Int


function range___len__(self: Ref): Int
  requires issubtype(typeof(self), range())
  ensures result == |range___val__(self)|


function range___getitem__(self: Ref, index: Int): Int
  requires issubtype(typeof(self), range())
  requires index >= 0 ==> index < range___len__(self)
  requires index < 0 ==> index >= -range___len__(self)
  ensures index >= 0 ==> result == range___val__(self)[index]
  ensures index < 0 ==> result == range___val__(self)[range___len__(self) + index]


function range___getitem_slice__(self: Ref, index: Ref): Ref
  requires issubtype(typeof(self), range())
  requires issubtype(typeof(index), slice())
  requires (slice___actualstart__(index, range___len__(self)) >= 0 && slice___actualstart__(index, range___len__(self)) <= range___len__(self))
  requires (slice___actualstop__(index, range___len__(self)) >= 0 && slice___actualstop__(index, range___len__(self)) <= range___len__(self))
  ensures issubtype(typeof(result), range())
  ensures range___len__(result) == (slice___actualstop__(index, range___len__(self)) - slice___actualstart__(index, range___len__(self)))
  ensures range___val__(result) == range___val__(self)[slice___actualstart__(index, range___len__(self))..slice___actualstop__(index, range___len__(self))]
//{
//    range___create__(range___val__(self)[slice___actualstart__(index, range___len__(self))], range___val__(self)[slice___actualstop__(index, range___len__(self)) - 1] + 1, newCtr(self))
//}


function range___sil_seq__(self: Ref): Seq[Ref]
  requires issubtype(typeof(self), range())
  ensures |result| == range___len__(self)
  ensures (forall i: Int :: i >= 0 && i < |range___val__(self)| ==> result[i] == __prim__int___box__(range___val__(self)[i]))
  ensures (forall i: Ref :: { (i in result) } (i in result) == (issubtype(typeof(i), int()) && (int___unbox__(i) in range___val__(self))))
  ensures (forall i: Int, j: Int :: result[i] == result[j] <==> i == j)


function range___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), range())
  ensures (range___val__(self) == range___val__(other)) == result
  ensures result ==> (issubtype(typeof(other), range()) && range___len__(self) == range___len__(other))


function range___contains__(self: Ref, item: Ref): Bool
    requires issubtype(typeof(self), range())
    requires issubtype(typeof(item), int())
    ensures result == (item in range___sil_seq__(self))

method range___iter__(self: Ref) returns (_res: Ref)
  requires issubtype(typeof(self), range())
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures _res.list_acc == range___sil_seq__(self)
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous, write) && ((_res.__previous != _res) && ((_res.__previous != self) && (acc(_res.__previous.list_acc, write) && (_res.__previous.list_acc == Seq[Ref]()))))
  ensures issubtype(typeof(_res.__previous), list(int()))
{
  inhale false
}