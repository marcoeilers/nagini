field list_acc : Seq[Ref]

field __container : Ref
field __iter_index : Int
field __previous: Ref

function object___bool__(self: Ref) : Bool
    ensures result == (self != null)

function NoneType___bool__(self: Ref) : Bool
    ensures result == (self != null)

function bool___bool__(self: Bool) : Bool
    ensures result == self

function int___bool__(self: Int) : Bool
    ensures result == (self != 0)

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    unique function int(): PyType
    unique function bool(): PyType
    unique function range(): PyType
    function get_type_arg1(obj: Ref, index: Int): PyType
}

function __prim__int___box__(prim: Int): Ref
    ensures typeof(result) == int()
    ensures int___unbox__(result) == prim
    ensures forall other: Int :: {__prim__int___box__(other)} ((__prim__int___box__(other) == result) <==> (other == prim))

function int___unbox__(box: Ref): Int
    requires issubtype(typeof(box), int())
    ensures !issubtype(typeof(box), bool()) ==> __prim__int___box__(result) == box
    ensures issubtype(typeof(box), bool()) ==> __prim__bool___box__(result != 0) == box

function __prim__bool___box__(prim: Bool): Ref
    ensures typeof(result) == bool()
    ensures bool___unbox__(result) == prim
    ensures int___unbox__(result) == (prim ? 1 : 0)

function bool___unbox__(box: Ref): Bool
    requires issubtype(typeof(box), bool())
    ensures __prim__bool___box__(result) == box

function int___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), int())
    requires issubtype(typeof(other), int())
{
    int___unbox__(self) == int___unbox__(other)
}

function bool___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), bool())
    requires issubtype(typeof(other), bool())
{
    bool___unbox__(self) == bool___unbox__(other)
}

function int___ge__(self: Int, other: Int): Bool
{
    self >= other
}

function int___gt__(self: Int, other: Int): Bool
{
    self > other
}

function int___le__(self: Int, other: Int): Bool
{
    self <= other
}

function int___lt__(self: Int, other: Int): Bool
{
    self < other
}

function int___add__(self: Int, other: Int): Int
{
    self + other
}

function int___sub__(self: Int, other: Int): Int
{
    self - other
}

function int___mul__(self: Int, other: Int): Int
{
    self * other
}

function int___floordiv__(self: Int, other: Int): Int
    requires other != 0
{
    self \ other
}

function int___mod__(self: Int, other: Int): Int
    requires other != 0
{
    self % other
}

function range___create__(start: Int, stop: Int): Ref
  requires stop >= start
  ensures range___val__(result) == [start..stop)
  ensures range___start__(result) == start
  ensures range___stop__(result) == stop
  ensures typeof(result) == range()


function range___val__(self: Ref): Seq[Int]

function range___start__(self: Ref): Int
function range___stop__(self: Ref): Int


function range___len__(self: Ref): Int
  ensures result == |range___val__(self)|


function range___getitem__(self: Ref, index: Ref): Int
  requires issubtype(typeof(index), int())
  requires (int___unbox__(index) in range___val__(self))
  ensures result == range___val__(self)[int___unbox__(index)]


function range___sil_seq__(self: Ref): Seq[Ref]
  ensures |result| == range___len__(self)
  ensures (forall i: Int :: i >= 0 && i < |range___val__(self)| ==> result[i] == __prim__int___box__(range___val__(self)[i]))
  ensures (forall i: Ref :: { (i in result) } (i in result) == (issubtype(typeof(i), int()) && (int___unbox__(i) in range___val__(self))))
  //ensures forall end: Int :: {range___sil_seq__(range___create__(range___start__(self), end))} (end < range___stop__(self) && end >= range___start__(self)) ==> result == range___sil_seq__(range___create__(range___start__(self), end))[..range___stop__(self)]


function range___contains__(self: Ref, item: Ref): Bool
    requires issubtype(typeof(item), int())
    ensures result == (item in range___sil_seq__(self))

method range___iter__(self: Ref) returns (_res: Ref)
  ensures _res != self
  ensures acc(_res.list_acc, 1 / 20)
  ensures _res.list_acc == range___sil_seq__(self)
  ensures acc(_res.__container, write) && (_res.__container == self)
  ensures acc(_res.__iter_index, write) && (_res.__iter_index == 0)
  ensures acc(_res.__previous, write) && ((_res.__previous != _res) && ((_res.__previous != self) && (acc(_res.__previous.list_acc, write) && (_res.__previous.list_acc == Seq[Ref]()))))
  ensures get_type_arg1(_res, 0) == int()
{
  inhale false
}

function object___eq__(self: Ref, other: Ref): Bool
    ensures self == other ==> result
    ensures ((self == null) != (other == null)) ==> !result

function Place___eq__(self: Ref, other: Ref): Bool
    ensures result == (self == other)

function object___cast__(typ: PyType, obj: Ref): Ref
    requires issubtype(typeof(obj), typ)
    ensures result == obj
    ensures issubtype(typeof(obj), typ)