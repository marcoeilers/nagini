field val : Int
field state : State
domain MethodID{
    unique function DummyObjIncr() : MethodID
    unique function DummyObjDecr() : MethodID
}
domain State{
    unique function CREATED() : State
    unique function STARTED() : State
    unique function JOINED() : State

    function cons(s : State) : State

    axiom const {
        forall s : State :: s == cons(s)
    }
    axiom enum {
        forall s : State :: {cons(s)} s == CREATED() || s == STARTED() || s == JOINED()
    }
}


function __prim__int___box__(prim: Int): Ref
    ensures isInt(result)
    ensures int___unbox__(result) == prim

function int___unbox__(box: Ref): Int
    requires isInt(box)
    ensures __prim__int___box__(result) == box

function __prim__bool___box__(prim: Bool): Ref
    ensures isBool(result)
    ensures bool___unbox__(result) == prim

function bool___unbox__(box: Ref): Bool
    requires isBool(box)
    ensures __prim__bool___box__(result) == box

domain BoxHelper{
    function isInt(r : Ref) : Bool
    function isBool(r : Ref) : Bool
}


domain Thread{
    function getMethod(t : Ref) : MethodID
    function getArgs(t : Ref) : Seq[Ref]
    function getOlds(t : Ref) : Seq[Ref]
    function getArg(t : Ref, i : Int) : Ref
    function getOld(t : Ref, i : Int) : Ref
    
    axiom Arg{
        forall t : Ref, i : Int :: (0 <= i && i < |getArgs(t)|) ==> getArg(t,i) == getArgs(t)[i]
    }
    axiom Old{
        forall t : Ref, i : Int :: (0 <= i && i < |getOlds(t)|) ==> getOld(t,i) == getOlds(t)[i]
    }
}

define isThread(t)
    acc(t.state)


method isAlive(thrref : Ref) returns (b : Bool)
    requires isThread(thrref)
    ensures isThread(thrref) && thrref.state == old(thrref.state)
    ensures thrref.state != STARTED() ==> !b

method joining(thrref : Ref) returns (b : Bool)
    requires acc(thrref.state) && thrref.state != CREATED()
    ensures acc(thrref.state)
    && thrref.state == JOINED() && (b == (old(thrref.state) == STARTED()))
    {
        //assert(cons(thrref.state) == JOINED() || cons(thrref.state) == STARTED() || cons(thrref.state) == CREATED())
        assert thrref.state == cons(thrref.state)
        if (thrref.state == JOINED()) {
            b := false
        } elseif (thrref.state == STARTED()) {
            thrref.state := JOINED()
            b := true
        }
    }
method init(struct : Ref, value : Int)
    requires acc(struct.val)
    ensures acc(struct.val) && struct.val == value
    {
        struct.val := value
    }

method incr(struct : Ref)
    requires acc(struct.val)
    ensures acc(struct.val) && struct.val == old(struct.val) +1
    {
        struct.val := struct.val + 1
    }

method decr(struct : Ref)
    requires acc(struct.val)
    ensures acc(struct.val) && struct.val == old(struct.val) -1
    {
        struct.val := struct.val - 1
    }
method test()
    {
        var x : Ref 
        x := new(val)
        init(x,1) //Those 3 lines are "x = DummyObj(1)"
        var t : Ref
        t := new(state)
        t.state := CREATED()
        assume getMethod(t) == DummyObjIncr() && getArgs(t) == Seq(x)
        // Creation of t.

        var z : Ref
        z := x 

        x.val := 3

        label prestart_t
        exhale acc(getArgs(t)[0].val)
        t.state := STARTED() // t.start()

        var y : Ref
        y := x
        
        var b : Bool
        b := joining(t)
        if(b){
            inhale(t.state == JOINED() ==> acc(getArgs(t)[0].val) 
                    && (getArgs(t)[0].val == old[prestart_t](getArgs(t)[0].val) + 1))
        } // This is joining t.
        assert (y.val == 4 && z.val == 4)
    }

method ThreadJoinerForIncrDecr(t : Ref, struct : Ref, v : Int)
    requires isThread(t) && (t.state != CREATED()) 
    requires isInt(getOld(t,0)) && int___unbox__(getOld(t,0)) == v
    requires getArg(t,0) == struct
    ensures isThread(t) && (t.state == JOINED())
    ensures ((getMethod(t) == DummyObjIncr() && old(t.state) == STARTED()) ==> (acc(struct.val) && struct.val == v + 1))
    ensures ((getMethod(t) == DummyObjDecr() && old(t.state) == STARTED()) ==> (acc(struct.val) && struct.val == v - 1)) 
    {
        var b : Bool
        b := joining(t)
        if(b){
                inhale (t.state == JOINED() ==> 
                    (getMethod(t) == DummyObjIncr() ==> acc(getArg(t,0).val) && (getArg(t,0).val == int___unbox__(getOld(t,0)) + 1)) &&
                    (getMethod(t) == DummyObjDecr() ==> acc(getArg(t,0).val) && (getArg(t,0).val == int___unbox__(getOld(t,0)) - 1 )))
                
        }
    }
    
method test2()
    {
        var x : Ref 
        x := new(val)
        init(x,1) //Those lines are "x = DummyObj(1)"

        var t : Ref
        t := new(state)
        t.state := CREATED()
        assume getMethod(t) == DummyObjIncr() && getArgs(t) == Seq(x)
        var z : Ref
        z := x 

        x.val := 3

        label prestart_t
        var temp : Ref
        temp := __prim__int___box__(x.val)
        assume getOlds(t) == Seq(temp)
        exhale (getMethod(t) == DummyObjIncr() ==> acc(getArgs(t)[0].val))
        t.state := STARTED()
        
        var y : Ref
        y := x
        assert (getMethod(t) == DummyObjIncr())

        ThreadJoinerForIncrDecr(t,y,old[prestart_t](x.val))
        assert (t.state == JOINED())
        assert (getMethod(t) == DummyObjIncr())
        assert (acc(y.val))
        assert (y.val == 4 && z.val == 4)
    }

method test3()
    {
        var x : Ref
        x := new(val)
        init(x,1)
        var t : Ref
        if(x.val < 2){
            
            t := new(state)
            assume getMethod(t) == DummyObjIncr() && getArgs(t) == Seq(x)
            t.state := CREATED()
        }
        else{
            t := new(state)
            t.state := CREATED()
            assume getMethod(t) == DummyObjDecr() && getArgs(t) == Seq(x)
        }
        var z : Ref
        z := x 


        label prestart_t
        var temp : Ref
        temp := __prim__int___box__(getArgs(t)[0].val)
        assume getOlds(t) == Seq(temp)
        exhale (
        (t.state == CREATED())
        &&
        (getMethod(t) == DummyObjIncr() || getMethod(t) == DummyObjDecr())
        &&
        (getMethod(t) == DummyObjIncr() ==> acc(getArgs(t)[0].val)) 
        && 
        (getMethod(t) == DummyObjDecr() ==> acc(getArgs(t)[0].val))
        )
        t.state := STARTED() //Those 3 lines are the start of t. 

        var y : Ref
        y := x

        
        var b : Bool
        b := joining(t)
        if(b){
            inhale(t.state == JOINED() ==> 
                    (getMethod(t) == DummyObjIncr() ==> acc(getArgs(t)[0].val) 
                            && (getArgs(t)[0].val == old[prestart_t](getArgs(t)[0].val) + 1)) &&
                    (getMethod(t) == DummyObjDecr() ==> acc(getArgs(t)[0].val) 
                            && (getArgs(t)[0].val == old[prestart_t](getArgs(t)[0].val) - 1 )))
        } 
        assert (y.val == 2 && z.val == 2)
    }